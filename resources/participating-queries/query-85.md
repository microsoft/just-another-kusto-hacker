[Click to run](https://dataexplorer.azure.com/clusters/help/databases/Samples?query=H4sIAAAAAAAEAL1Y7W4btxL976cgDFxEQiVHUvxR2VctVNeJEyd1GiftvS0KgdqlJNar5Zbk2lHRB7p9jr7YPTPcL0m2GyBGBcOQZsmZM8OZM7N8+nT0qJ+dp0/Fe+0TdSxejS/OxelCJolK50qcpd6uRFf8oOcq/et/liSRXWVem1S8tcbMhExjcZn7LPekZpz7hbHH4rVKpXihp86kHXGRO29I1yJ3Wjpe+K30MDfOrE5Ev9cRg97ggOT8TLnIajZyzNgW2gn8LVdCMaCZscIvlNh9Bc1inBr8sIWZcxldK7srWuRKW0Qm9cr5vaBHid9yBQWRVdLrG5WshGHsjvVZ9VuurYpFtrDSPaif9E2BRFusUGlkYp3OhfYCLuILaQNqb6yOGtGLdEaabrVfiN2LD1fvL3eFDLav1apDSvE9FbEKUQ4q/cKafL4QF9+/FiZTVlJkHLlEG35cSE+rYrWE1OOpchy2rjgt3AQoJXBWrNTMrcwWK4HQp8CTKMQ2Jd1hzzi+kWmEGEAV2V/KVGd5wjZFJDM51Yn2Wrli+dXpy5ciWkgrIw/XEAglACJ1OKRlQBpWvjEx1FghLbxfKo/A6CXML3GmvK5Ylided51XmYillxu6RKYzlehUFc6fm1vyfZYnM50kIZJRmb7HITw6Uety4cjwqjxuV+QAh/uBIy+OB4noTJIzGi+vsV1W+SRkllkjowVyg63398SVl5ZV86kTkCJmiJSrUjlkHG0Z7KEsAI+2yO3cUXUBtqToH0JnhAjmyOrMJCuZZAs55eiGDW3S+WwPRdVMqSlcEnDNqhslE0aAVJ3rFD9qKPvYpl2WyFWZ0zNegZjhlIT6iDNHHJHBD1fKevFRAFUy61JpShxlzBxi8xQHkeL7SjyXU6qbsxs4dm44ea0Y/54jCgV3SHH2MUuMpYxLYK0oKhwkUOEXoYxVptIY8UKydsRSKXYeOVCSAo5NY62WZSk9z1Mxg0/HjHa7bCUhjFCrqblN2e2E0krPZlik0/ivP8MPOU0UM0SLYoYHKmggeXksIs4VnYAG9yCe4AoqO5LMKC8BG4GFGys8InyPTPmJ8gWSCZhHjEo6OhGA/cGFirk1NhZP+METctfktowFNpGDpya9UdaXDEbwHULgxY1McqR3azwCuX8z6nfE6WjQEcpHe3t77YrVuXBUxYDFZmmtXIlUqRjJUVZIfRwymRsmEfYC2ya8zcGLDDk34e2tHYEPxf6jmbV2x9+cfnv2/MX5y1cXr998d/n2+3dX7z/88ON//vvTbke4fBrYrlWHpCMAvN9udyggF1Dd7322xn6t8QM0Dj5f46DWeEUYv/xsjc9qje9J4/CzNe6zRkEaL0nj/k77hBLgEtmkUxBvIPruBkkvlXNyTk05Q32ACYgo3J0Nx3Ei8JMzasVYOWKlniqulRl3rFPf4V0Tek4/2+Jndg2HcgSIggG+YhFFtX/UCaJcsIzi0j8oZI5F5Fj/sBB5FmHBs0GpzCEbFYux6PCgFI9ZdESbe8XmlEVfkqhfiAyLhtsmaFO/R4ghWgQRJVavH0TBYp99KFbZIHpWglvDRouOSscuguigDAD5H0SHpf+V+/2jElyNrXKh8qA/vNPqAF4cleLzIMK+YRl1GURYMRwWoiiI6CB6BbbrINrfcn/AHuyLwv1fOOG4rT7UUcs+tbVEU5PfaK+c7NoXgwANYWhUtC5GC1AWCStOpXKYeAKpEY8pGg2Qq0hcTtnCtIrfFMk+WsvinT+4m6E7EskhjYnh8P9fgSEnVCh+0aoZsC3u/xBbyySiUS5wLTRpBs+DyZLGs9wRg99iQIQFk8NwQcx3IYGbrerXiOjyPlSdcle7RHKOll+OZTRp3yLKVOpLSUzDAe+JFnX+BC8MNVRMqlDVXocT4jtqdIKfC3vd/i8PRKQOzAsVWlijd6ENm2WzuYSm1Op1pwAcB0YE1TWwaDfJM8zn7NGoZhvx1Qjlz1NOLfv3SAx7dx7SQmE207MGxyEateJWYMDDg+6wt248Mbd3Gx8ebRvvDwafbLxWXBgfHnWxf906lwalRTMKxq4De/gYXrowX0sMV405toTydW1vGrykFGzaCzRbSCurgVZ67famvboe6PBZZ/AvZEBrTPhlw00zmznla8OMsiNadWS7Qc0Xdea0Ua6DQ7K/bZYX0PtmI79LzynVBgcN4xVZBEubIAq7AWKj17VP1nwOJBgS3aQJj2x3BZvf2orpn8Ojis5a9uXqdaZmy1ApmAMW5rZ6Y8gxcDdeWvB+FEHDzib1wU88+lVFXO2d+nWkkcudjRhUvNIRWxzQCW2bP6WuCWnCojzVtJ11ZAazgJt4MylHlypwne0MvSxRVXGqrTSwfYKZdU/aa1bOymcNM3/AC2LGKRM3JqHoJNyV8FIOdXky0xW/19nqJmLjhLj1FFcMzdZzx5Fs2nzUjlS6eyWXGx0pKiqEvhf3I3UK7T1qMypBNDpS3YbMTPQetdeU1u5oOPf2kY26r5vJxoOtjlLxeWNahkp3b9PYtlR0jm1LoP9HZf8S8D/aAqooVYS82QP+nvo3QlPwf7eRLF+A/htNAPbecXWqRga0ZMwXiIND5uMbo2O8/87DpVKaL6dY32gFVfF+Uiu4l2rqfmALROt9IUyqjXypE+lv2G0d4FbUGzcH5U1Uk+lcvlxKq39X4gp6lJ+8DfexI7qUjKQv3vCX8lpNEu18q9qM6n7yZNMcvdcZ7qwN3qZbTwq1IJZE4QfgjS70LlxyjdYxnGy68ilJfYV+uHV9trPJwP8HizxsIdcXAAA=)

```kql
//==============================================================================
// Title: JAKH Challenge Entry - Vigenère Encryption Proof and Output
// Author: ***
// Date: ***
// 
// Description:
// This is my entry for the "Just Another Kusto Hacker" (JAKH) contest.
// The query creatively outputs the required phrase "Just Another Kusto Hacker"
// by first encoding it using the historic Vigenère cipher with "KUSTO" as the key,
// then decrypting it through KQL operations.
//
// What it demonstrates:
// - Creative use of cryptography principles in KQL
// - Advanced string manipulation capabilities
// - ASCII character code transformations
// - Modular arithmetic implementation
// - Multi-step data transformation pipeline
//
// How it fulfills the challenge:
// While the challenge simply requires outputting "Just Another Kusto Hacker",
// this solution takes a creative approach by:
// 1. Starting with the ASCII codes for the phrase
// 2. Applying a Vigenère cipher encryption (a 16th century polyalphabetic cipher)
// 3. Decrypting it back to reveal the original phrase
// 4. Displaying the final result exactly as "Just Another Kusto Hacker"
//
// The query is self-contained and runs on any Fabric EventHouse or Azure 
// Data Explorer cluster without external dependencies, meeting all contest criteria.
//
// Fun fact: The Vigenère cipher was once known as "le chiffre indéchiffrable"
// (the indecipherable cipher) due to its resistance to frequency analysis.
//==============================================================================
let cipher_key = "KUSTO"; // Use the word 'KUSTO' as our cipher key
// Convert the key to shift values (A=0, B=1, C=2, etc...)
// This creates the key shift array needed for the Vigenère algorithm
let key_shifts = pack_array(
    indexof("ABCDEFGHIJKLMNOPQRSTUVWXYZ", substring(cipher_key, 0, 1)), // K = 10
    indexof("ABCDEFGHIJKLMNOPQRSTUVWXYZ", substring(cipher_key, 1, 1)), // U = 20
    indexof("ABCDEFGHIJKLMNOPQRSTUVWXYZ", substring(cipher_key, 2, 1)), // S = 18
    indexof("ABCDEFGHIJKLMNOPQRSTUVWXYZ", substring(cipher_key, 3, 1)), // T = 19
    indexof("ABCDEFGHIJKLMNOPQRSTUVWXYZ", substring(cipher_key, 4, 1))  // O = 14
);
// Our input data - the challenge message represented as ASCII character codes
let ASCIIEncoded = datatable(pos:int, char_code:int) [
    1, 74,    // J
    2, 117,   // u 
    3, 115,   // s
    4, 116,   // t
    5, 32,    // space
    6, 65,    // A
    7, 110,   // n
    8, 111,   // o
    9, 116,   // t
    10, 104,  // h
    11, 101,  // e
    12, 114,  // r
    13, 32,   // space
    14, 75,   // K
    15, 117,  // u
    16, 115,  // s
    17, 116,  // t
    18, 111,  // o
    19, 32,   // space
    20, 72,   // H
    21, 97,   // a
    22, 99,   // c
    23, 107,  // k
    24, 101,  // e
    25, 114   // r
];
// Apply Vigenère cipher encryption
// The Vigenère cipher is a polyalphabetic substitution that uses a different Caesar shift for each letter
let encryptedMessage = ASCIIEncoded
| extend key_pos = pos % array_length(key_shifts)                           // Calculate key position with modulus to wrap around the key
| extend key_pos = iff(key_pos == 0, array_length(key_shifts), key_pos)     // Handle the case where remainder is 0 (use last position in key)
| extend key_shift = key_shifts[key_pos-1]                                  // Get the shift value from key_shifts array (0-based indexing)
| extend is_uppercase = char_code >= 65 and char_code <= 90                 // Check if character is uppercase (ASCII 65-90)
| extend is_lowercase = char_code >= 97 and char_code <= 122                // Check if character is lowercase (ASCII 97-122)
| extend is_alpha = is_uppercase or is_lowercase                            // Is this an alphabetic character?
| extend base = iff(is_uppercase, 65, iff(is_lowercase, 97, 0))             // Calculate the base ASCII value (A or a)
| extend offset = iff(is_alpha, (char_code - base + key_shift) % 26, 0)     // Calculate shifted position in alphabet (0-25)
| extend encrypted_code = iff(is_alpha, base + offset, char_code);          // Apply shift only to alphabetic characters
// Display the encoded message with the Vigenère shifts, showing the full encryption process
encryptedMessage
| project pos, original = char_code, encrypted_code, key_pos, shift = key_shift, 
         original_char = unicode_codepoints_to_string(char_code),               // Original character
         encrypted_char = unicode_codepoints_to_string(encrypted_code)          // Encrypted character
| order by pos asc;
// Decrypt the message by reversing the Vigenère shift
let decryptedMessage = encryptedMessage
| order by pos asc
| extend key_pos = pos % array_length(key_shifts)                                // Same key position calculation as the encryption.
| extend key_pos = iff(key_pos == 0, array_length(key_shifts), key_pos)          // Handle the remainder of 0
| extend key_shift = key_shifts[key_pos-1]                                       // Get the shift value
| extend is_uppercase = encrypted_code >= 65 and encrypted_code <= 90            // Check character cases
| extend is_lowercase = encrypted_code >= 97 and encrypted_code <= 122
| extend is_alpha = is_uppercase or is_lowercase                                 // Is this an alphabetic character?
| extend base = iff(is_uppercase, 65, iff(is_lowercase, 97, 0))                  // Calculate base ASCII value
| extend offset = iff(is_alpha, (encrypted_code - base - key_shift + 26) % 26, 0) // Reverse the shift (adding 26 to avoid negative numbers)
| extend decrypted_code = iff(is_alpha, base + offset, encrypted_code)           // Apply reverse shift only to letters
| extend character = unicode_codepoints_to_string(decrypted_code)                // Convert back to character
| summarize Secret_Phrase = strcat_array(make_list(character), '')               // Join all characters into a single string
| project Result = Secret_Phrase;                                                 // Show the final result
decryptedMessage
```